Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1. (a) Escreva uma função em C que calcule a raiz quadrada 'x' de uma variável 'S' do tipo float, utilizando o seguinte algoritmo: após 'n+1' iterações, a raiz quadrada de 'S' é dada por

	x(n+1) = (x(n) + S/x(n))/2

O protótipo da função é:
Resposta:
   unsigned int Raiz_Quadrada(unsigned int S){
        int interacoes = 15;
        float x0 = S;
        float x;
        int n;
        for(n = 0; n <= interacoes; n++){
            x = (x0 + (S/x0))/2;
            x0 = x;
        }
    }

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável 'S' é fornecida pelo registrador R15, e a raiz quadrada de 'S' (ou seja, a variável 'x') é fornecida pelo registrador R15 também.

CalculaRaiz: 	mov.w R15,R12; copia o valor de "S" em R12.

x0 = R13
S = R15

Divide:                   ;calcula div R15/R13 e guarda em R15 --> (R15 = R15/R13)
	  mov.w #0,R12    ; registrador teste para divisao  		
	  mov.w num2,R13  ; R13 é o denominador(x0)
Mult: 	  add.w #0,R12    ; verifica se R12 é zero, retornando 0 na mult caso afirmativo//
	  jz fimMult 	  ; ocorrerá apenas quando a mult for Zero.
	  add.w R13,R14   ; copia R13(denominador) para R14(resultado da mult) 
	  sub.w #1,R12    ; subtrai R12 (variavel teste) para determinar o fim da mult.
	  jz fimMult	  ; se R12 for Zero, a multiplicação terminou
	  jmp mult	  ; looping para somar repetidas vezes até R12 ser Zero.
fimMult:		   
	  cmp.w R14,R15   ; compara o resultado da mult com R15(numerador).
	  jl.w pararDiv	  ; Se R15 for menor que R14(resultado_mult), então o valor anterior é o resultado da div...Divisão termina.
	  add.w #1,R12	  ; Adc 1 na variavel teste e testa outro valor que multiplicando o denominador é igual ao numerador.
	  jmp Mult        ; Multiplica por esse looping "n" valores com o denominador até esse valor exceder o numerador.
pararDiv: sub #1,R14	  ; subtrai o valor testado(quando for maior que o numerador)e termina a divisão
	  mov.w R14,R15   ; como o resultado deve ser mostrado em R15 ... R15 = R14.
			  ; ------------------------------------------------------- 
	  add.w R13,R15	  ; R15 = Xo + (S/Xo)
	  rra.w R15	  ;       -----------
			  ;            2

2. (a) Escreva uma função em C que calcule 'x' elevado à 'N'-ésima potência, seguindo o seguinte protótipo: 

	int Potencia(int x, int N);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. 'x' e 'n' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida no registrador R15.

3. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula a divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

4. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

5. (a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, e 0, caso contrário. Siga o seguinte protótipo:

	int Primalidade(unsigned int x);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

6. Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!. Se n for ímpar, n!! = 1*3*5*...*n, e se n for par, n!! = 2*4*6*...*n. Por exemplo, 9!! = 1*3*5*7*9 = 945 e 10!! = 2*4*6*8*10 = 3840. Além disso, 0!! = 1!! = 1.
O protótipo da função é:

	unsigned long long DuploFatorial(unsigned long long n);

7. (a) Escreva uma função em C que calcula a função exponencial da seguinte forma:
	
Considere o cálculo até o termo n = 20. O protótipo da função é double ExpTaylor(double x);
(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430, mas considere que os valores de entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

8. Escreva uma sub-rotina na linguagem Assembly do MSP430 que indica se um vetor esta ordenado de forma decrescente. Por exemplo:
[5 4 3 2 1] e [90 23 20 10] estão ordenados de forma decrescente.
[1 2 3 4 5] e [1 2 3 2] não estão.
O primeiro endereço do vetor é fornecido pelo registrador R15, e o tamanho do vetor é fornecido pelo registrador R14. A saída deverá ser fornecida no registrador R15, valendo 1 quando o vetor estiver ordenado de forma decrescente, e valendo 0 em caso contrário.

9. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o produto escalar de dois vetores, 'a' e 'b':
	
O primeiro endereço do vetor 'a' deverá ser passado através do registrador R15, o primeiro endereço do vetor 'b' deverá ser passado através do registrador R14, e o tamanho do vetor deverá ser passado pelo registrador R13. A saída deverá ser fornecida no registrador R15.

10. (a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo:
	[1 2 3 2 1] e [0 10 20 20 10 0] são palíndromos.
	[5 4 3 2 1] e [1 2 3 2] não são.
Se o vetor for palíndromo, retorne o valor 1. Caso contrário, retorne o valor 0. O protótipo da função é:

	int Palindromo(int vetor[ ], int tamanho);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. O endereço do vetor de entrada é dado pelo registrador R15, o tamanho do vetor é dado pelo registrador R14, e o resultado é dado pelo registrador R15.